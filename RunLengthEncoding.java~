/* RunLengthEncoding.java */
//ac_best
/**
 *  The RunLengthEncoding class defines an object that run-length encodes
 *  a PixImage object.  Descriptions of the methods you must implement appear
 *  below.  They include constructors of the form
 *
 *      public RunLengthEncoding(int width, int height);
 *      public RunLengthEncoding(int width, int height, int[] red, int[] green,
 *                               int[] blue, int[] runLengths) {
 *      public RunLengthEncoding(PixImage image) {
 *
 *  that create a run-length encoding of a PixImage having the specified width
 *  and height.
 *
 *  The first constructor creates a run-length encoding of a PixImage in which
 *  every pixel is black.  The second constructor creates a run-length encoding
 *  for which the runs are provided as parameters.  The third constructor
 *  converts a PixImage object into a run-length encoding of that image.
 *
 *  See the README file accompanying this project for additional details.
 */

import java.util.Iterator;

public class RunLengthEncoding implements Iterable {

  /**
   *  Define any variables associated with a RunLengthEncoding object here.
   *  These variables MUST be private.
   */

      public static final int SINGLELENGTH = 0;
      public static final int FRONTBOUNDRY = 1;
      public static final int BACKBOUNDRY = 2;
      public static final int MIDPOINT = 3;
    
    
    
    private RunNode head;
    private RunNode tail;
    private int size;
    private int width;
    private int height;



  /**
   *  The following methods are required for Part II.
   */

  /**
   *  RunLengthEncoding() (with two parameters) constructs a run-length
   *  encoding of a black PixImage of the specified width and height, in which
   *  every pixel has red, green, and blue intensities of zero.
   *
   *  @param width the width of the image.
   *  @param height the height of the image.
   */

  public RunLengthEncoding(int width, int height) {
    // Your solution here.
      RunNode node = new RunNode(new Pixel((short) 0, (short) 0, (short) 0), width * height);
      head = node;
      tail = node;
      size++;
  }

  /**
   *  RunLengthEncoding() (with six parameters) constructs a run-length
   *  encoding of a PixImage of the specified width and height.  The runs of
   *  the run-length encoding are taken from four input arrays of equal length.
   *  Run i has length runLengths[i] and RGB intensities red[i], green[i], and
   *  blue[i].
   *
   *  @param width the width of the image.
   *  @param height the height of the image.
   *  @param red is an array that specifies the red intensity of each run.
   *  @param green is an array that specifies the green intensity of each run.
   *  @param blue is an array that specifies the blue intensity of each run.
   *  @param runLengths is an array that specifies the length of each run.
   *
   *  NOTE:  All four input arrays should have the same length (not zero).
   *  All pixel intensities in the first three arrays should be in the range
   *  0...255.  The sum of all the elements of the runLengths array should be
   *  width * height.  (Feel free to quit with an error message if any of these
   *  conditions are not met--though we won't be testing that.)
   */

  public RunLengthEncoding(int width, int height, int[] red, int[] green,
                           int[] blue, int[] runLengths) {
    // Your solution here.
      int runSum = 0;
      for (int i = 0; i < runLengths.length; i++) {
          RunNode node = new RunNode(new Pixel((short) red[i], (short) green[i], (short) blue[i]), runLengths[i]);
          if (size == 0) {
              head = node;
          } else {
              tail.setNext(node);
              node.setPrev(tail);
          }
          tail = node;
          size++;
          runSum += runLengths[i];
      }
      if (runSum != width * height) {
          System.out.println("runSum != width * height");
          System.exit(0);
      }
  }

  private void insertLast(RunNode node) {
      if (size == 0) {
              head = node;
      } else {
          tail.setNext(node);
          node.setPrev(tail);
      }
      tail = node;
      size++;
  }
  
  
  /**
   *  getWidth() returns the width of the image that this run-length encoding
   *  represents.
   *
   *  @return the width of the image that this run-length encoding represents.
   */

  public int getWidth() {
    // Replace the following line with your solution.
    return width;
  }

  /**
   *  getHeight() returns the height of the image that this run-length encoding
   *  represents.
   *
   *  @return the height of the image that this run-length encoding represents.
   */
  public int getHeight() {
    // Replace the following line with your solution.
    return height;
  }


  public RunNode getHead() {
    return head;
  }

  /**
   *  iterator() returns a newly created RunIterator that can iterate through
   *  the runs of this RunLengthEncoding.
   *
   *  @return a newly created RunIterator object set to the first run of this
   *  RunLengthEncoding.
   */
  public RunIterator iterator() {
    // Replace the following line with your solution.
    return new RunIterator(head);
    // You'll want to construct a new RunIterator, but first you'll need to
    // write a constructor in the RunIterator class.
  }

  /**
   *  toPixImage() converts a run-length encoding of an image into a PixImage
   *  object.
   *
   *  @return the PixImage that this RunLengthEncoding encodes.
   */
  public PixImage toPixImage() {
    // Replace the following line with your solution.
      RunIterator iter = iterator();
      PixImage img = new PixImage(width, height);
      Pixel[] tempPixel = new Pixel[width * height];
      int tempCount = 0;
      while (iter.hasNext()) {
          int[] ints = iter.next();
          for (int i = 0; i < ints[0]; i++) {
              tempPixel[tempCount] = new Pixel((short) ints[1], (short) ints[2], (short) ints[3]);
              tempCount++;
          }   
      }
      tempCount = 0;
      for (int j = 0; j < height; j++) {
          for (int i = 0; i < width; i++) {
              img.setPixel(i, j, tempPixel[tempCount].getRed(), tempPixel[tempCount].getGreen(), tempPixel[tempCount].getBlue());
              tempCount++;
          }
      }
      
    return img;
  }

  /**
   *  toString() returns a String representation of this RunLengthEncoding.
   *
   *  This method isn't required, but it should be very useful to you when
   *  you're debugging your code.  It's up to you how you represent
   *  a RunLengthEncoding as a String.
   *
   *  @return a String representation of this RunLengthEncoding.
   */
  public String toString() {
    // Replace the following line with your solution.
    return "";
  }


  /**
   *  The following methods are required for Part III.
   */

  /**
   *  RunLengthEncoding() (with one parameter) is a constructor that creates
   *  a run-length encoding of a specified PixImage.
   * 
   *  Note that you must encode the image in row-major format, i.e., the second
   *  pixel should be (1, 0) and not (0, 1).
   *
   *  @param image is the PixImage to run-length encode.
   */
  public RunLengthEncoding(PixImage image) {
    // Your solution here, but you should probably leave the following line
    // at the end.
      if (image == null) {
          return;
      }
      width = image.getWidth();
      height = image.getHeight();
      Pixel[][] pixels = image.getPixels();
      Pixel prevPixel = null;
      int currLen = 0;
      for (int j = 0; j < height; j++) {
          for (int i = 0; i < width; i++) {
              if (prevPixel == null) {
                  prevPixel = pixels[i][j];
                  currLen++;
              } else {
                  //if (prevPixel.equals(pixels[i][j])) {
                  if (prevPixel.getRed() == pixels[i][j].getRed() && prevPixel.getGreen() == pixels[i][j].getGreen() && prevPixel.getBlue() == pixels[i][j].getBlue()) {
                      currLen++;
                  } else {
                      RunNode node = new RunNode(prevPixel, currLen);
                      insertLast(node);
                      currLen = 1;
                      prevPixel = pixels[i][j];
                  }
              }
          }
      }
      insertLast(new RunNode(prevPixel, currLen));
      
      check();
  }

  /**
   *  check() walks through the run-length encoding and prints an error message
   *  if two consecutive runs have the same RGB intensities, or if the sum of
   *  all run lengths does not equal the number of pixels in the image.
   */
  public void check() {
    // Your solution here.
      RunIterator iter = iterator();
      int runSum = 0;
      int prevRed = -1;
      int prevGreen = -1;
      int prevBlue = -1;
      while (iter.hasNext()) {
          int[] ints = iter.next();
          if (ints[0] < 1) {
              System.out.println("Run has a length less than 1.");
          }
          if (prevRed == ints[1] && prevGreen == ints[2] && prevBlue == ints[3]) {
              System.out.println("Two consecutive runs have the same RGB intensities.");
          }
          prevRed = ints[1];
          prevGreen = ints[2];
          prevBlue = ints[3];
          runSum+=ints[0];
      }
      if (runSum != width * height) {
          System.out.println("Sum of all run lengths does not equal the number of pixels in the image.");
      }
  }


  /**
   *  The following method is required for Part IV.
   */

  /**
   *  setPixel() modifies this run-length encoding so that the specified color
   *  is stored at the given (x, y) coordinates.  The old pixel value at that
   *  coordinate should be overwritten and all others should remain the same.
   *  The updated run-length encoding should be compressed as much as possible;
   *  there should not be two consecutive runs with exactly the same RGB color.
   *
   *  @param x the x-coordinate of the pixel to modify.
   *  @param y the y-coordinate of the pixel to modify.
   *  @param red the new red intensity to store at coordinate (x, y).
   *  @param green the new green intensity to store at coordinate (x, y).
   *  @param blue the new blue intensity to store at coordinate (x, y).
   */
  public void setPixel(int x, int y, short red, short green, short blue) {
    // Your solution here, but you should probably leave the following line
    //   at the end.
      //make sure x y red green blue are valid
      Pixel newPixel = new Pixel(red, green, blue);
      int position = x + (y * width) + 1;
      RunNode node = head;
      int runSum = 0;
      int interval = 0;
      while (node != null) {
          interval = node.getLen();
          runSum += interval;
          if (runSum >= position) {
              if (newPixel.equals(node.getPixel())) {
                  break;
              }
              updatePixel(newPixel, node, position, runSum, interval);
              break;
          }
          node = node.getNext();
      }
      
      
    check();
  }
  
  // public static final int SINGLELENGTH = 0;
  // public static final int FRONTBOUNDRY = 1;
  // public static final int BACKBOUNDRY = 2;
  // public static final int MIDPOINT = 3;

  
  private void updatePixel(Pixel newPixel, RunNode node, int position, int runSum, int interval) {
      int positionType = getPositionType(position, interval, runSum);
      switch (positionType) {
          case SINGLELENGTH:
              if (size == 1) {
                  node.setPixel(newPixel);
              } else {
                  if (node == head) {
                      if (newPixel.equals(node.getNext().getPixel())) {
                          node.getNext().setLen(node.getNext().getLen() + 1);
                          node.getNext().setPrev(null);
                          head = node.getNext();
                      } else {
                          node.setPixel(newPixel);
                      }
                  } else if (node == tail) {
                      if (newPixel.equals(node.getPrev().getPixel())) {
                          node.getPrev().setLen(node.getPrev().getLen() + 1);
                          node.getPrev().setNext(null);
                          tail = node.getPrev();
                      } else {
                          node.setPixel(newPixel);
                      }
                  } else {
                      if (newPixel.equals(node.getPrev().getPixel()) && newPixel.equals(node.getNext().getPixel())) {
                          node.getPrev().setLen(node.getPrev().getLen() + 1 + node.getNext().getLen());
                          RunNode afterNext = node.getNext().getNext();
                          node.getPrev().setNext(afterNext);
                          if (afterNext != null) {
                              afterNext.setPrev(node.getPrev());
                          }
                      } else if (newPixel.equals(node.getPrev().getPixel())) {
                          node.getPrev().setLen(node.getPrev().getLen() + 1);
                          node.getPrev().setNext(node.getNext());
                          node.getNext().setPrev(node.getPrev());
                      } else if (newPixel.equals(node.getNext().getPixel())) {
                          node.getNext().setLen(node.getNext().getLen() + 1);
                          node.getNext().setPrev(node.getPrev());
                          node.getPrev().setNext(node.getNext());
                      } else {
                          node.setPixel(newPixel);
                      }
                  }
              }
              break;
          case FRONTBOUNDRY:
              if (node == head) {
                  RunNode newNode = new RunNode(newPixel, 1);
                  node.setLen(node.getLen() - 1);
                  newNode.setNext(node);
                  node.setPrev(newNode);
                  head = newNode;
              } else if (newPixel.equals(node.getPrev().getPixel())) {
                  node.getPrev().setLen(node.getPrev().getLen() + 1);
                  node.setLen(node.getLen() - 1);
              } else {
                  RunNode newNode = new RunNode(newPixel, 1);
                  node.setLen(node.getLen() - 1);
                  newNode.setNext(node);
                  newNode.setPrev(node.getPrev());
                  node.getPrev().setNext(newNode);
                  node.setPrev(newNode);
              }
              break;
          case BACKBOUNDRY:
              if (node == tail) {
                  RunNode newNode = new RunNode(newPixel, 1);
                  node.setLen(node.getLen() - 1);
                  newNode.setPrev(node);
                  node.setNext(newNode);
                  tail = newNode;
              } else if (newPixel.equals(node.getNext().getPixel())) {
                  node.getNext().setLen(node.getNext().getLen() + 1);
                  node.setLen(node.getLen() - 1);
              } else {
                  RunNode newNode = new RunNode(newPixel, 1);
                  node.setLen(node.getLen() - 1);
                  newNode.setPrev(node);
                  newNode.setNext(node.getNext());
                  node.getNext().setPrev(newNode);
                  node.setNext(newNode);
              }
              break;
          case MIDPOINT:
              int len1 = position - (runSum - interval) - 1;
              RunNode newNode1 = new RunNode(node.getPixel(), len1);
              RunNode newNode2 = new RunNode(newPixel, 1);
              RunNode newNode3 = new RunNode(node.getPixel(), runSum - position);
              if (size == 1) {
                  newNode1.setNext(newNode2);
                  newNode2.setNext(newNode3);
                  newNode2.setPrev(newNode1);
                  newNode3.setPrev(newNode2);
                  head = newNode1;
                  tail = newNode3;
              } else {
                  if (node == head) {
                      newNode1.setNext(newNode2);
                      newNode2.setNext(newNode3);
                      newNode3.setNext(node.getNext());
                      newNode2.setPrev(newNode1);
                      newNode3.setPrev(newNode2);
                      node.getNext().setPrev(newNode3);
                      head = newNode1;
                  } else if (node == tail) {
                      newNode1.setNext(newNode2);
                      newNode2.setNext(newNode3);
                      newNode1.setPrev(node.getPrev());
                      newNode2.setPrev(newNode1);
                      newNode3.setPrev(newNode2);
                      node.getPrev().setNext(newNode1);
                      tail = newNode3;
                  } else {
                      newNode1.setNext(newNode2);
                      newNode2.setNext(newNode3);
                      newNode3.setNext(node.getNext());
                      newNode1.setPrev(node.getPrev());
                      newNode2.setPrev(newNode1);
                      newNode3.setPrev(newNode2);
                      node.getPrev().setNext(newNode1);
                      node.getNext().setPrev(newNode3);
                  }
              }
              break;
      }
  }

  
  private int getPositionType(int position, int interval, int runSum) {
      int positionType = -1;
    // *****
    // ***** we can further merget interval >= 3 & interval == 2 into only 1 condition --> interval >= 2
    // *****
      if (interval >= 2) {
        // node's run-length is 3 or more
          if (position == runSum) {
              positionType = BACKBOUNDRY; // compare with the next node
          } else if (position == (runSum - interval + 1)) {
              positionType = FRONTBOUNDRY;  // compare with the prev node
          } else {
              positionType = MIDPOINT;  // split the current node into 3 new nodes
          }
      } else {
          // node's run-length is 1
          positionType = SINGLELENGTH;
      }
      return positionType;
  } // end of getPositionType()


  /**
   * TEST CODE:  YOU DO NOT NEED TO FILL IN ANY METHODS BELOW THIS POINT.
   * You are welcome to add tests, though.  Methods below this point will not
   * be tested.  This is not the autograder, which will be provided separately.
   */


  /**
   * doTest() checks whether the condition is true and prints the given error
   * message if it is not.
   *
   * @param b the condition to check.
   * @param msg the error message to print if the condition is false.
   */
  private static void doTest(boolean b, String msg) {
    if (b) {
      System.out.println("Good.");
    } else {
      System.err.println(msg);
    }
  }

  /**
   * array2PixImage() converts a 2D array of grayscale intensities to
   * a grayscale PixImage.
   *
   * @param pixels a 2D array of grayscale intensities in the range 0...255.
   * @return a new PixImage whose red, green, and blue values are equal to
   * the input grayscale intensities.
   */
  private static PixImage array2PixImage(int[][] pixels) {
    int width = pixels.length;
    int height = pixels[0].length;
    PixImage image = new PixImage(width, height);

    for (int x = 0; x < width; x++) {
      for (int y = 0; y < height; y++) {
        image.setPixel(x, y, (short) pixels[x][y], (short) pixels[x][y],
                       (short) pixels[x][y]);
      }
    }

    return image;
  }

  /**
   * setAndCheckRLE() sets the given coordinate in the given run-length
   * encoding to the given value and then checks whether the resulting
   * run-length encoding is correct.
   *
   * @param rle the run-length encoding to modify.
   * @param x the x-coordinate to set.
   * @param y the y-coordinate to set.
   * @param intensity the grayscale intensity to assign to pixel (x, y).
   */
  private static void setAndCheckRLE(RunLengthEncoding rle,
                                     int x, int y, int intensity) {
    rle.setPixel(x, y,
                 (short) intensity, (short) intensity, (short) intensity);
    rle.check();
  }

  private static void printPixImage(PixImage img) {
    for (int j = 0; j < img.getHeight(); j++) {
      for (int i = 0; i < img.getWidth(); i++) {
        System.out.print(img.getRed(i,j)+"/");
        System.out.print(img.getGreen(i,j)+"/");
        System.out.print(img.getBlue(i,j)+",");
      }
      System.out.println(" ");
    }
    System.out.println(" ");
  }
  
  private static void printNodes(RunNode node) {
    while (node != null) {
      System.out.println("***** node length: " + node.getLen() + " color: " + node.getPixel().getRed());
      node = node.getNext();
    }
  }

  /**
   * main() runs a series of tests of the run-length encoding code.
   */
  public static void main(String[] args) {
    // Be forwarned that when you write arrays directly in Java as below,
    // each "row" of text is a column of your image--the numbers get
    // transposed.

    //          0 1 2
    // image1   3 4 5
    //          6 7 8
    System.out.println("\n#        #");
    System.out.println(  "# image1 #");
    System.out.println(  "#        #\n");
    PixImage image1 = array2PixImage(new int[][] { { 0, 3, 6 },
                                                   { 1, 4, 7 },
                                                   { 2, 5, 8 } });
        
    System.out.println("image1 width: " + image1.getWidth());
    System.out.println("image1 height: " + image1.getHeight());
    printPixImage(image1);

    System.out.println("Testing one-parameter RunLengthEncoding constuctor " +
                       "on a 3x3 image.  Input image:");
    System.out.print(image1);
    RunLengthEncoding rle1 = new RunLengthEncoding(image1);
    rle1.check();
    System.out.println("Testing getWidth/getHeight on a 3x3 encoding.");
    doTest(rle1.getWidth() == 3 && rle1.getHeight() == 3,
           "RLE1 has wrong dimensions");

    System.out.println("Testing toPixImage() on a 3x3 encoding.");
    doTest(image1.equals(rle1.toPixImage()),
           "image1 -> RLE1 -> image does not reconstruct the original image");

    System.out.println("Testing setPixel() on a 3x3 encoding. 0, 0, 42");
    setAndCheckRLE(rle1, 0, 0, 42);
    image1.setPixel(0, 0, (short) 42, (short) 42, (short) 42);

    PixImage prle1 = rle1.toPixImage();
    System.out.println("\nimage1:");
    printPixImage(image1);
    System.out.println("\nrle1:");
    printPixImage(prle1);
    System.out.println("rle1 nodes:");
    printNodes(rle1.getHead());

    doTest(rle1.toPixImage().equals(image1),
           /*
                       array2PixImage(new int[][] { { 42, 3, 6 },
                                                    { 1, 4, 7 },
                                                    { 2, 5, 8 } })),
           */
           "Setting RLE1[0][0] = 42 fails.");

    System.out.println("Testing setPixel() on a 3x3 encoding. 1, 0, 42");
    setAndCheckRLE(rle1, 1, 0, 42);
    image1.setPixel(1, 0, (short) 42, (short) 42, (short) 42);

    prle1 = rle1.toPixImage();
    System.out.println("\nimage1:");
    printPixImage(image1);
    System.out.println("\nrle1:");
    printPixImage(prle1);
    System.out.println("rle1 nodes:");
    printNodes(rle1.getHead());

    doTest(rle1.toPixImage().equals(image1),
           "Setting RLE1[1][0] = 42 fails.");

    System.out.println("Testing setPixel() on a 3x3 encoding. 0, 1, 2");
    setAndCheckRLE(rle1, 0, 1, 2);
    image1.setPixel(0, 1, (short) 2, (short) 2, (short) 2);

    prle1 = rle1.toPixImage();
    System.out.println("\nimage1:");
    printPixImage(image1);
    System.out.println("\nrle1:");
    printPixImage(prle1);
    System.out.println("rle1 nodes:");
    printNodes(rle1.getHead());

    doTest(rle1.toPixImage().equals(image1),
           "Setting RLE1[0][1] = 2 fails.");

    System.out.println("Testing setPixel() on a 3x3 encoding. 0, 0, 0");
    setAndCheckRLE(rle1, 0, 0, 0);
    image1.setPixel(0, 0, (short) 0, (short) 0, (short) 0);

    prle1 = rle1.toPixImage();
    System.out.println("\nimage1:");
    printPixImage(image1);
    System.out.println("\nrle1:");
    printPixImage(prle1);
    System.out.println("rle1 nodes:");
    printNodes(rle1.getHead());

    doTest(rle1.toPixImage().equals(image1),
           "Setting RLE1[0][0] = 0 fails.");

    System.out.println("Testing setPixel() on a 3x3 encoding. 2, 2, 7");
    setAndCheckRLE(rle1, 2, 2, 7);
    image1.setPixel(2, 2, (short) 7, (short) 7, (short) 7);

    prle1 = rle1.toPixImage();
    System.out.println("\nimage1:");
    printPixImage(image1);
    System.out.println("\nrle1:");
    printPixImage(prle1);
    System.out.println("rle1 nodes:");
    printNodes(rle1.getHead());

    doTest(rle1.toPixImage().equals(image1),
           "Setting RLE1[2][2] = 7 fails.");

    System.out.println("Testing setPixel() on a 3x3 encoding. 2, 2, 42");
    setAndCheckRLE(rle1, 2, 2, 42);
    image1.setPixel(2, 2, (short) 42, (short) 42, (short) 42);

    prle1 = rle1.toPixImage();
    System.out.println("\nimage1:");
    printPixImage(image1);
    System.out.println("\nrle1:");
    printPixImage(prle1);
    System.out.println("rle1 nodes:");
    printNodes(rle1.getHead());

    doTest(rle1.toPixImage().equals(image1),
           "Setting RLE1[2][2] = 42 fails.");

    System.out.println("Testing setPixel() on a 3x3 encoding. 1, 2, 42");
    setAndCheckRLE(rle1, 1, 2, 42);
    image1.setPixel(1, 2, (short) 42, (short) 42, (short) 42);

    prle1 = rle1.toPixImage();
    System.out.println("\nimage1:");
    printPixImage(image1);
    System.out.println("\nrle1:");
    printPixImage(prle1);
    System.out.println("rle1 nodes:");
    printNodes(rle1.getHead());

    doTest(rle1.toPixImage().equals(image1),
           "Setting RLE1[1][2] = 42 fails.");

    //          2 2 3
    // image2   3 4 4
    //          5 5 6
    System.out.println("\n#        #");
    System.out.println(  "# image2 #");
    System.out.println(  "#        #\n");
    PixImage image2 = array2PixImage(new int[][] { { 2, 3, 5 },
                                                   { 2, 4, 5 },
                                                   { 3, 4, 6 } });

    System.out.println("image2 width: " + image2.getWidth());
    System.out.println("image2 height: " + image2.getHeight());
    printPixImage(image2);
                                                   
    System.out.println("Testing one-parameter RunLengthEncoding constuctor " +
                       "on another 3x3 image.  Input image:");
    System.out.print(image2);
    RunLengthEncoding rle2 = new RunLengthEncoding(image2);
    rle2.check();
    System.out.println("Testing getWidth/getHeight on a 3x3 encoding.");
    doTest(rle2.getWidth() == 3 && rle2.getHeight() == 3,
           "RLE2 has wrong dimensions");

    System.out.println("Testing toPixImage() on a 3x3 encoding.");
    doTest(rle2.toPixImage().equals(image2),
           "image2 -> RLE2 -> image does not reconstruct the original image");

    System.out.println("Testing setPixel() on a 3x3 encoding. 0, 1, 2");
    setAndCheckRLE(rle2, 0, 1, 2);
    image2.setPixel(0, 1, (short) 2, (short) 2, (short) 2);

    PixImage prle2 = rle2.toPixImage();
    System.out.println("\nimage2:");
    printPixImage(image2);
    System.out.println("\nrle2:");
    printPixImage(prle2);
    System.out.println("rle2 nodes:");
    printNodes(rle2.getHead());
    
    doTest(rle2.toPixImage().equals(image2),
           "Setting RLE2[0][1] = 2 fails.");

    System.out.println("Testing setPixel() on a 3x3 encoding. 2, 0, 2");
    setAndCheckRLE(rle2, 2, 0, 2);
    image2.setPixel(2, 0, (short) 2, (short) 2, (short) 2);

    prle2 = rle2.toPixImage();
    System.out.println("\nimage2:");
    printPixImage(image2);
    System.out.println("\nrle2:");
    printPixImage(prle2);
    System.out.println("rle2 nodes:");
    printNodes(rle2.getHead());
    
    doTest(rle2.toPixImage().equals(image2),
           "Setting RLE2[2][0] = 2 fails.");

    //          0 1 2 3 4 
    // image3   5 6 7 8 9
    //          
    System.out.println("\n#        #");
    System.out.println(  "# image3 #");
    System.out.println(  "#        #\n");
    PixImage image3 = array2PixImage(new int[][] { { 0, 5 },
                                                   { 1, 6 },
                                                   { 2, 7 },
                                                   { 3, 8 },
                                                   { 4, 9 } });

    System.out.println("image3 width: " + image3.getWidth());
    System.out.println("image3 height: " + image3.getHeight());
    printPixImage(image3);
                                                   
    System.out.println("Testing one-parameter RunLengthEncoding constuctor " +
                       "on a 5x2 image.  Input image:");
    System.out.print(image3);
    RunLengthEncoding rle3 = new RunLengthEncoding(image3);
    rle3.check();
    System.out.println("Testing getWidth/getHeight on a 5x2 encoding.");
    doTest(rle3.getWidth() == 5 && rle3.getHeight() == 2,
           "RLE3 has wrong dimensions");

    System.out.println("Testing toPixImage() on a 5x2 encoding.");
    doTest(rle3.toPixImage().equals(image3),
           "image3 -> RLE3 -> image does not reconstruct the original image");

    System.out.println("Testing setPixel() on a 5x2 encoding. 4, 0, 6");
    setAndCheckRLE(rle3, 4, 0, 6);
    image3.setPixel(4, 0, (short) 6, (short) 6, (short) 6);

    PixImage prle3 = rle3.toPixImage();
    System.out.println("\nimage3:");
    printPixImage(image3);
    System.out.println("\nrle3:");
    printPixImage(prle3);
    System.out.println("rle3 nodes:");
    printNodes(rle3.getHead());
    
    doTest(rle3.toPixImage().equals(image3),
           "Setting RLE3[4][0] = 6 fails.");

    System.out.println("Testing setPixel() on a 5x2 encoding. 0, 1, 6");
    setAndCheckRLE(rle3, 0, 1, 6);
    image3.setPixel(0, 1, (short) 6, (short) 6, (short) 6);

    prle3 = rle3.toPixImage();
    System.out.println("\nimage3:");
    printPixImage(image3);
    System.out.println("\nrle3:");
    printPixImage(prle3);
    System.out.println("rle3 nodes:");
    printNodes(rle3.getHead());
    
    doTest(rle3.toPixImage().equals(image3),
           "Setting RLE3[0][1] = 6 fails.");

    System.out.println("Testing setPixel() on a 5x2 encoding. 0, 0, 1");
    setAndCheckRLE(rle3, 0, 0, 1);
    image3.setPixel(0, 0, (short) 1, (short) 1, (short) 1);

    prle3 = rle3.toPixImage();
    System.out.println("\nimage3:");
    printPixImage(image3);
    System.out.println("\nrle3:");
    printPixImage(prle3);
    System.out.println("rle3 nodes:");
    printNodes(rle3.getHead());
    
    doTest(rle3.toPixImage().equals(image3),
           "Setting RLE3[0][0] = 1 fails.");

    //          0 1 2
    // image4   3 4 5
    //          
    System.out.println("\n#        #");
    System.out.println(  "# image4 #");
    System.out.println(  "#        #\n");
    PixImage image4 = array2PixImage(new int[][] { { 0, 3 },
                                                   { 1, 4 },
                                                   { 2, 5 } });

    System.out.println("image4 width: " + image4.getWidth());
    System.out.println("image4 height: " + image4.getHeight());
    printPixImage(image4);

    System.out.println("Testing one-parameter RunLengthEncoding constuctor " +
                       "on a 3x2 image.  Input image:");
    System.out.print(image4);
    RunLengthEncoding rle4 = new RunLengthEncoding(image4);
    rle4.check();
    System.out.println("Testing getWidth/getHeight on a 3x2 encoding.");
    doTest(rle4.getWidth() == 3 && rle4.getHeight() == 2,
           "RLE4 has wrong dimensions");

    System.out.println("Testing toPixImage() on a 3x2 encoding.");
    doTest(rle4.toPixImage().equals(image4),
           "image4 -> RLE4 -> image does not reconstruct the original image");

    System.out.println("Testing setPixel() on a 3x2 encoding. 2, 0, 0");
    setAndCheckRLE(rle4, 2, 0, 0);
    image4.setPixel(2, 0, (short) 0, (short) 0, (short) 0);

    PixImage prle4 = rle4.toPixImage();
    System.out.println("\nimage4:");
    printPixImage(image4);
    System.out.println("\nrle4:");
    printPixImage(prle4);
    System.out.println("rle4 nodes:");
    printNodes(rle4.getHead());
    
    doTest(rle4.toPixImage().equals(image4),
           "Setting RLE4[2][0] = 0 fails.");

    System.out.println("Testing setPixel() on a 3x2 encoding. 1, 0, 0");
    setAndCheckRLE(rle4, 1, 0, 0);
    image4.setPixel(1, 0, (short) 0, (short) 0, (short) 0);

    prle4 = rle4.toPixImage();
    System.out.println("\nimage4:");
    printPixImage(image4);
    System.out.println("\nrle4:");
    printPixImage(prle4);
    System.out.println("rle4 nodes:");
    printNodes(rle4.getHead());
    
    doTest(rle4.toPixImage().equals(image4),
           "Setting RLE4[1][0] = 0 fails.");

    System.out.println("Testing setPixel() on a 3x2 encoding. 1, 0, 1");
    setAndCheckRLE(rle4, 1, 0, 1);
    image4.setPixel(1, 0, (short) 1, (short) 1, (short) 1);

    prle4 = rle4.toPixImage();
    System.out.println("\nimage4:");
    printPixImage(image4);
    System.out.println("\nrle4:");
    printPixImage(prle4);
    System.out.println("rle4 nodes:");
    printNodes(rle4.getHead());
    
    doTest(rle4.toPixImage().equals(image4),
           "Setting RLE4[1][0] = 1 fails.");
  }
}
